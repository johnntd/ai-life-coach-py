<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AI Life Coach</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="mobile-web-app-capable" content="yes" />
  <link rel="icon" href="/static/favicon.ico" />
<<<<<<< HEAD
  <link rel="stylesheet" href="/static/style.css?v=ios-audio-1" />
=======
  <link rel="stylesheet" href="/static/style.css?v=3" />
>>>>>>> REV0
  <script type="importmap">
  {
    "imports": {
      "three": "/static/vendor/three-r152.2/build/three.module.js",
      "three/addons/": "/static/vendor/three-r152.2/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="wrap">
    <!-- 3D avatar (fills screen) -->
    <section id="avatarWrap">
      <canvas id="avatarCanvas"></canvas>
      <!-- Legacy hook for CSS .talking -->
      <div id="avatar"></div>
    </section>

    <!-- Chat + Controls -->
    <aside id="controlPanel" style="padding: 12px;">

      <!-- Auth Status & Model Info -->
      <div id="authStatus" style="font-size:13px; opacity:.7; margin-bottom:6px;"></div>
      <div id="log"></div>
      <p id="model"></p>

      <!-- Chat Input (leave exactly as-is) -->
      <div class="row" style="margin-bottom: 12px; gap: 8px;">
        <input id="text" type="text" placeholder="Type a message…" style="flex:1" />
        <button id="send">Send</button>
      </div>

      <!-- Camera + Upload + Modes (one line) -->
      <div id="cameraUploadRow">
        <button id="cameraBtn" class="btn action-pill">Camera</button>
        <button id="uploadBtn" class="btn action-pill">Upload</button>
        <button id="studyBtn" class="btn action-pill" aria-pressed="false">Study</button>
        <button id="interpreterBtn" class="btn action-pill" aria-pressed="false">Interpreter</button>
        <button id="tutorBtn" class="btn action-pill" aria-pressed="false">Tutor</button>
      </div>

      <input id="fileInput" type="file" accept="image/*,.pdf" hidden>

      <!-- SigninBtn signupBnt logoutBtn -->
      <div class="row" style="gap: 8px; flex-wrap: wrap; margin-bottom: 10px;">
  <button id="loginBtn">Login</button>
  <button id="signupBtn">Sign Up</button>
  <button id="logoutBtn" style="display:none;">Logout</button>
</div>
      <!-- Login Form -->
      <form id="login-form" class="row" style="gap:8px;flex-wrap:wrap;display:none;">
        <input id="email" type="email" placeholder="Email" required />
        <input id="password" type="password" placeholder="Password" required />
        <button type="submit" id="enterLogin">Enter</button>
      </form>

      <!-- Signup Form -->
      <div id="signupFields" class="row" style="gap: 8px; flex-wrap: wrap; display: none;">
        <input id="firstName" placeholder="First Name" />
        <input id="lastName" placeholder="Last Name" />
        <input id="age" type="number" placeholder="Age" />
        <select id="sex">
          <option value="">Select Sex</option>
          <option value="f">Female</option>
          <option value="m">Male</option>
        </select>
        <select id="lang">
          <option value="en-US">English</option>
          <option value="vi-VN">Vietnamese</option>
        </select>
        <input id="emailSignup" type="email" placeholder="Email" />
        <input id="passwordSignup" type="password" placeholder="Password" />
        <button id="enterSignup">Enter</button>
      </div>

      <!-- Status message -->
      <div id="status" style="margin: 8px 0;">Idle</div>
    </aside>

    <!-- Camera Modal (used by cameraBtn) -->
    <div id="cameraModal" style="display:none; position:fixed; inset:0; background:#0009; z-index:1000; align-items:center; justify-content:center;">
      <div style="background:#0b1f3a; padding:16px; border-radius:12px; width:min(720px,95vw);">
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
          <strong style="color:#fff">Camera</strong>
          <div style="flex:1"></div>
          <button id="closeCamera" class="btn">Close</button>
        </div>
        <video id="cameraVideo" autoplay playsinline style="width:100%; border-radius:12px; background:#111"></video>
        <canvas id="cameraCanvas" width="1280" height="720" style="display:none"></canvas>
        <div style="display:flex; gap:8px; margin-top:10px;">
          <button id="captureBtn" class="btn">Capture</button>
          <button id="retakeBtn" class="btn" style="display:none;">Retake</button>
          <div style="flex:1"></div>
          <button id="sendSnapshotBtn" class="btn" style="display:none;">Send to Tutor</button>
        </div>
        <small style="color:#bcd; display:block; margin-top:6px;">
          Tip: point at a page/exercise—Sunny will explain or help solve it.
        </small>
      </div>
    </div>

    <!-- TTS audio (also used for lip-sync) -->
<<<<<<< HEAD
  <audio id="ttsAudio" preload="auto" playsinline></audio>
=======
    <audio id="ttsAudio" preload="auto"></audio>
>>>>>>> REV0
  </div>

  <!-- Three.js avatar viewer + lip-sync (kept stable) -->
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader }    from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const canvas  = document.getElementById('avatarCanvas');
    const audioEl = document.getElementById('ttsAudio');

    const scene = new THREE.Scene();
    scene.background = null;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

    // Shoulders-up framing
    const camera = new THREE.PerspectiveCamera(22, 1, 0.1, 100);
    camera.position.set(0, 1.52, 1.25);
    scene.add(camera);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableZoom = false;
    controls.enablePan  = false;
    controls.target.set(0, 1.52, 0);
    controls.update();

    // Lights
    {
      const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8);
      hemi.position.set(0, 1, 0);
      scene.add(hemi);

      const key = new THREE.DirectionalLight(0xffffff, 1.0);
      key.position.set(3, 5, 4);
      scene.add(key);

      const fill = new THREE.DirectionalLight(0xb0c4ff, 0.6);
      fill.position.set(-4, 3, 2);
      scene.add(fill);

      const rim = new THREE.DirectionalLight(0x8090ff, 0.6);
      rim.position.set(0, 3, -3);
      scene.add(rim);
    }

    function onResize(){
      const rect = canvas.getBoundingClientRect();
      const w = rect.width  || canvas.clientWidth  || window.innerWidth;
      const h = rect.height || canvas.clientHeight || window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / Math.max(1, h);
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    // Load model
    const loader = new GLTFLoader();
    let headMesh=null, mouthIndex=-1, headBone=null, jawBone=null, eyeL=null, eyeR=null;

    loader.load('/static/models/coach.glb', (gltf)=>{
      const root = gltf.scene;
      root.traverse(obj=>{
        if (obj.isMesh) obj.frustumCulled = false;
        if (!headMesh && obj.isMesh && obj.morphTargetDictionary && /Head/i.test(obj.name)) headMesh = obj;
        if (!headBone && /Head\b/i.test(obj.name)) headBone = obj;
        if (!jawBone  && /jaw/i.test(obj.name))   jawBone  = obj;
        if (!eyeL     && /LeftEye/i.test(obj.name)) eyeL   = obj;
        if (!eyeR     && /RightEye/i.test(obj.name)) eyeR  = obj;
      });
      scene.add(root);

      if (headMesh && headMesh.morphTargetDictionary){
        const d = headMesh.morphTargetDictionary;
        mouthIndex = d.mouthOpen ?? d.MouthOpen ?? d.jawOpen ?? d.JawOpen ?? -1;
      }

      controls.target.set(0, 1.52, 0);
      camera.position.set(0, 1.52, 1.25);
      camera.lookAt(controls.target);

      console.log('[avatar] mouth morph:', mouthIndex>=0?'mouthOpen':'(none)');
      console.log('[avatar] jaw bone:',   jawBone?jawBone.name:'(none)');
      console.log('[avatar] head bone:',  headBone?headBone.name:'(none)');

      onResize();
      animate();
    }, undefined, (e)=>console.error('[avatar] load error', e));

    // Lip-sync
    let ctx=null, analyser=null, srcNode=null, wired=false, usedCapture=false;
    async function wireLipSyncOnce(){
      if (wired) return; wired=true;
      try{
        ctx = new (window.AudioContext||window.webkitAudioContext)();
        await ctx.resume();

        if (audioEl.captureStream){
          const stream = audioEl.captureStream();
          if (stream && stream.getAudioTracks().length){
            srcNode = ctx.createMediaStreamSource(stream);
            usedCapture = true;
            console.log('[avatar] lip-sync via captureStream()');
          }
        }
        if (!srcNode){
          srcNode = ctx.createMediaElementSource(audioEl);
          console.log('[avatar] lip-sync via createMediaElementSource()');
        }

        analyser = ctx.createAnalyser();
        analyser.fftSize = 1024;
        srcNode.connect(analyser);
        if (!usedCapture) srcNode.connect(ctx.destination); // ensure sound output
      }catch(e){
        wired=false;
        console.warn('[avatar] audio graph create failed', e);
      }
    }
    audioEl.addEventListener('play', wireLipSyncOnce, { once:true });

    // Mouth + subtle head motion
    let mouth=0, nf=0.004, gain=6.0, lastCal=0, gazeT=0, gx=0, gy=0;
    function updateMouth(){
      if (!analyser || !headMesh || mouthIndex<0) return;
      const buf = new Uint8Array(analyser.fftSize);
      analyser.getByteTimeDomainData(buf);
      let s=0; for (let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; s+=v*v; }
      const rms = Math.sqrt(s/buf.length);

      const t = performance.now();
      if (t-lastCal>2000){ nf = Math.max(0.0025, Math.min(0.02, 0.8*nf+0.2*rms)); lastCal=t; }

      let target = (rms-nf)*gain; target = Math.max(0, Math.min(1, target));
      const a = target>mouth ? 0.45 : 0.25;
      mouth += (target-mouth)*a;

      headMesh.morphTargetInfluences[mouthIndex]=mouth;
      if (jawBone){ jawBone.rotation.x = mouth*0.20; }
    }
    function updateGaze(dt){
      gazeT -= dt;
      if (gazeT<=0){ gazeT=0.7+Math.random()*0.9; gx=(Math.random()*2-1)*0.06; gy=(Math.random()*2-1)*0.04; }
      if (headBone){
        headBone.rotation.y += (gx - headBone.rotation.y)*0.08;
        headBone.rotation.x += (gy - headBone.rotation.x)*0.08;
      }
    }

    let last=performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const now=performance.now(); const dt=(now-last)/1000; last=now;
      updateMouth(); updateGaze(dt);
      renderer.render(scene, camera);
    }

    onResize();
  </script>
<<<<<<< HEAD
  <script type="module" src="/static/app.js?v=ios-audio-1"></script>
=======
<script type="module" src="/static/app.js?v=latency-baseline2"></script>

>>>>>>> REV0
</body>
</html>
